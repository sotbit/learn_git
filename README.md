<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
# Введение
Надеюсь после первой задачи вы научились отслеживать изменения файлов, а так же коммитить изменения.

Теперь давайте попробуем забрать из репозитория задачу выполненную другим разработчиком. В данном 
случае это будет очередной абзац нашего стихотворения
=======
# Cherry Pick

Существует еще один способ, слияния это *сherry pick*

# Что это? Зачем?
  Данный способ позволяет объединять вам не всю ветку, а только выборочные коммиты. Это 
  бывает достаточно удобно когда в каком-то коммите реализована нужная фича, но сама ветка 
  в стадии разработки.  
  Можно скопировать код, но представьте сложную реализацию, когда работа велась во множестве 
  файлов?
>>>>>>> f810a20 (4th paragraph)

## Задание 
1. **Работа ведется в вашей основной ветке**
2. Перейдите на вашу основную ветку и выполните команду **git cherry-pick commit**. Где 
   *commit* имя или хэш необходимого вам коммита. В нашем случае это *4th paragraph* и 
   *5th paragraph* из ветки **dev-task_5**
3. В результате на вашей ветке появятся коммиты с соответствующими абзацами.
4. Отправьте изменения в свой удаленный репозиторий, и сделайте PR.
5. Сообщите своему наставнику, о выполнении задания.

## На что обратить внимание
1. Обязательно посмотрите структуру коммитов в ветке  **dev-task_5**.
2. Обязательно посмотрите на структуру вашей основной ветки **до** и **после** сherry pick.
3. Команда сherry pick выполняется **на ветке в которую вы переносите** коммиты.

<<<<<<< HEAD
<<<<<<< HEAD
1. Из текущей ветки (dev-task_1) сознайте новую с именем состоящим из ваших ФИО, например *Vasia_Pupkin* это
   будет ваша основная ветка. От нее создайте еще одну ветку *task_1*
2. Добавьте в **index.html** первый абзац стихотворения
3. Выполните команду **git status**, обратите внимание на статус *modified* измененного файла
   Данный статус сообщает, что файл был изменен.
4. Создайте какой-либо файл и выполните **git status** еще раз, теперь вы должны увидеть,  
   что кроме *modified* git сообщает нам о *untracket files*, это означает, что этот файл   
   не отслеживается гитом
5. Добавьте ВСЕ изменения в коммит командой **git add -A**, выполните **git status**  
   обратите внимание, что все изменения готовы к коммиту *Changes to be committed*  
6. Внесите любую правку в свой тестовый, файл и проверьте статус **git status**,  
   теперь вы можете увидеть, что ваш файл отображается сразу в двух статусах.  
   Что бы добавить новые изменения к коммиту вам опять нужно выполнить **git add**  
   либо отменить ваши изменения командой **git checkout <nameFiles>** о чем вас проинформирует  
   консоль.  
   ***Важно отметить, что в коммит попадут только те изменения которые находятся в *staged* т.е.
   добавлены к коммиту. Очень важно контролировать изменения прикрепляемые к коммиту, так как 
   в него могут не попасть нужные изменения (вы забыли **git add**), либо попадут изменения 
   которых там быть не должно (например файлы пользователя)***
7. Попробуйте самостоятельно, добавлять файлы, вносить правки, добавлять к коммиту, сбрасывать изменения.
   Не бойтесь, что-либо сломать, это тренировка и она важна для понимания процессов.
8. Когда вы точно понимаете как управлять изменениями, создайте коммит **git commit** либо 
   **git commit -m <nameCommit>**, проверьте еще раз статус, там не должны отображаться изменения
   которые были добавленны к коммиту
9. Смержите основную ветку с веткой задачи, для этого перейдите в вашу основную ветку и выполните
   комманду git merge <name branch>, обязательно обратите внимание, что результатом вашего слияния
   стал новый коммит.
10. Отправьте ваши изменения в удаленный репозиторий **git push origin** где *origin* будет вашим
=======
1. Из вашей основной ветки **name_surname**, создайте новую ветку **task_2** и перейдите в нее.
2. Выполните команду *git pull origin dev-task_2*. Вы заберете второй абзац стихотворения который
   имитирует задачу выполненную другим разработчиком.
3. В случае если у вас появились конфликты слияния, разрешите их.
4. Смержите ветку **task_2** с **name_surname**.
5. Результатом вашей работы должны быть 2 столбца стихотворения.
6. Отправьте ваши изменения в удаленный репозиторий **git push origin** где *origin* будет вашим
>>>>>>> db5840c478b9e92d2f5490ef17bad8086adef67a
=======
# Более сложные конфликты

Попробуем воспроизвести ситуацию, когда один код меняется двумя разработчиками.

## Задание 

1. Из вашей основной ветки создайте ветку **task_3**
2. После предыдущего задания у вас должны быть два абзаца стихотворения, если это не так
   вернитесь и сделайте как положено )).
3. Заберите изменения из ветки *dev-task_3*, выполнив команду **git pull origin dev-task_3**
4. Вы можете увидеть, что теперь у вас есть конфликты с исправлением слов, разрешите их с
   помощью инструментов гит. Не стоит просто переписывать все ручками (хотя это может 
   показаться более простым способом), так как в реальных проектах конфликты будут гораздо 
   сложнее и просто переписать у вас не получится.
5. Смержите ветку *task_3* в вашу основную.
6. Отправьте ваши изменения в удаленный репозиторий git push origin где origin будет вашим 
>>>>>>> dc18a734e1b2352e4a4d2d55e6be1af8ed5c1cf9
   удаленным репозиторием, сделайте pull request.


## Может понадобится
В результате работы у вас могут появляться файлы, которых не должно быть в репозитории
(например файлы среды разработки), для того что бы они не висели в *статусе* добавьте 
их в **.gitignore**. Просто создайте этот файл и запишите в нем файл или папку которы не должен
отслеживать git.
=======
# Rebase

  Второй способ объединения изменений **git rebase**.  
  Объединять ваши ветки можно не только командой **git merge** но и командой **git rebase**.
  Многие могут спросить, зачем второй способ. Все дело в том как происходит объединение изменений. 
  Помните я говорил, что результатом мержа будет новый коммит? Так вот при *rebase* все коммиты 
  перенесутся в ветку последовательно, как будто разработка велась в одной ветке.  
  Давайте попробуем на практике.


## Задание 

1. **Работа ведется в вашей основной ветке**
2. **Обязательно** просмотрите структуру коммитов в ветке *dev-task_4* и в вашей основной ветке
3. Перейдите на ветку *dev-task_4* и выполните команду *git rebase <name_surname>*
4. **Обязательно** просмотрите структуру коммитов в вашей основной ветке. В каждом коммите будет
   по одной строке стихотворения. Теперь у вас есть 3 столбца, нашего стихотворения
   
## Проблемы
  Так как rebase это не волшебная палочка, скорее всего у вас возникнут конфликты при слиянии.
  В этот момент git остановит выполнение слияния, о чем напишет в консоли. Вам потребуется 
  разрешить конфликты, добавить файлы к коммиту **git add** и запустить продолжение слияния 
  **git rebase --continue**. Конфликты могут быть в каждом коммите, поэтому вам нужно будет
   их решить по мере того как это потребует git. 
   Не стоит бояться новых команд, git будет подсказывать и предлагать команды в консоли.
   
## На что обратить внимание
1. После выполнения *rebase* обратите внимание, что ваш HEAD отстает от последнего коммита,
   для того что бы все синхронизировать, перейдите на вашу главную ветку и выполните 
   **git merge dev-task_4**, еще раз проверьте структуру, теперь все должно быть норм.
2. На разницу выполнения команд:
    * *git merge* выполняется на ветке **в** которую вы хотите вмержить, 
    * *git rebase* на ветке **которую** вы хотите перенести
3. На итоговую историю коммитов:
    * при *merge* результат две ветки с общим коммитом мержа
    * при *rebase* результат все коммиты располагаются линейно
    
## Что использовать?
  В описанных случаях слияния есть как свои преимущества, так и свои недостатки. Данная тема 
  очень обширна и для использования того или иного способа могут быть различные предпосылки. 
  В любом случае надо уметь использовать оба, т.к. в разных командах или на разных проектах 
  вас могут попросить использовать какой-либо конкретный способ.
>>>>>>> ea69f57 (1st line)
=======
>>>>>>> f810a20 (4th paragraph)
